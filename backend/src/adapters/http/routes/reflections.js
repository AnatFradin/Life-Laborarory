/**
 * Reflections routes - HTTP endpoints for reflection management
 * 
 * GET    /api/reflections            - Get all reflections
 * POST   /api/reflections            - Create new reflection
 * GET    /api/reflections/:id        - Get specific reflection
 * DELETE /api/reflections/:id        - Delete specific reflection
 * POST   /api/reflections/delete-all - Delete all reflections (requires confirmation)
 */

import express from 'express';
import multer from 'multer';
import ReflectionService from '../../../domain/services/ReflectionService.js';
import repositoryFactory from '../../../domain/factories/RepositoryFactory.js';
import { validateBody } from '../middleware/validation.js';
import { ReflectionSchema } from '../../../domain/entities/Reflection.js';
import config from '../../../config/index.js';

const router = express.Router();

// Configure multer for memory storage (we'll handle file writing in the service)
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max file size
  },
});

// Helper function to get reflection service with correct storage location
async function getReflectionService() {
  const repository = await repositoryFactory.createReflectionRepository();
  return new ReflectionService(repository);
}

/**
 * GET /api/reflections
 * Get all reflections (sorted by timestamp desc)
 */
router.get('/', async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const reflections = await reflectionService.getAllReflections();
    res.json({
      reflections,
      count: reflections.length,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/reflections/:id
 * Get specific reflection by ID
 */
router.get('/:id', async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const { id } = req.params;
    const reflection = await reflectionService.getReflectionById(id);

    if (!reflection) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }

    res.json(reflection);
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections
 * Create new reflection
 * 
 * For text mode (JSON):
 *   Content-Type: application/json
 *   Body: { mode: 'text', content: '...' }
 * 
 * For visual mode (multipart/form-data):
 *   Content-Type: multipart/form-data
 *   Fields: mode=visual, image=<file>
 * 
 * id, timestamp, aiInteraction are generated by the service
 */
router.post(
  '/',
  upload.fields([
    { name: 'image', maxCount: 1 },  // Backward compatibility
    { name: 'images', maxCount: 10 } // Multiple images
  ]),
  async (req, res, next) => {
    try {
      const reflectionService = await getReflectionService();
      const { mode, content } = req.body;

      // Get files from either field
      const files = (req.files?.images || []).concat(req.files?.image || []);

      // Handle visual or mixed mode (image upload)
      if (mode === 'visual' || mode === 'mixed') {
        if (!files || files.length === 0) {
          const error = new Error('At least one image file is required for visual/mixed mode');
          error.statusCode = 400;
          throw error;
        }

        // Validate MIME types
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf'];
        for (const file of files) {
          if (!allowedTypes.includes(file.mimetype)) {
            const error = new Error(
              `Invalid file type. Allowed types: ${allowedTypes.join(', ')}`
            );
            error.statusCode = 400;
            throw error;
          }
        }

        // For mixed mode, content is required
        if (mode === 'mixed' && (!content || content.trim().length === 0)) {
          const error = new Error('Content is required for mixed mode');
          error.statusCode = 400;
          throw error;
        }

        // Handle single image (backward compatible with visual mode)
        if (files.length === 1 && mode === 'visual') {
          const file = files[0];
          // Extract dimensions if provided
          const dimensions = req.body.width && req.body.height
            ? { width: parseInt(req.body.width), height: parseInt(req.body.height) }
            : undefined;

          const imageData = {
            buffer: file.buffer,
            originalFilename: file.originalname,
            mimeType: file.mimetype,
            sizeBytes: file.size,
            dimensions,
          };

          const created = await reflectionService.importVisual(
            imageData,
            config.dataDir
          );

          res.status(201).json(created);
        } else {
          // Handle multiple images or mixed mode
          const imagesData = files.map(file => ({
            buffer: file.buffer,
            originalFilename: file.originalname,
            mimeType: file.mimetype,
            sizeBytes: file.size,
          }));

          const created = await reflectionService.createWithImages(
            { mode, content },
            imagesData,
            config.dataDir
          );

          res.status(201).json(created);
        }
      } 
      // Handle text mode (JSON)
      else {
        const reflectionData = req.body;
        const created = await reflectionService.createReflection(reflectionData);

        res.status(201).json(created);
      }
    } catch (error) {
      next(error);
    }
  }
);

/**
 * DELETE /api/reflections/:id
 * Delete a specific reflection
 */
router.delete('/:id', async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const { id } = req.params;
    const deleted = await reflectionService.deleteReflection(id);
    
    if (!deleted) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }
    
    res.json({
      message: 'Reflection deleted successfully',
      id,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections/delete-all
 * Delete all reflections (requires "DELETE_ALL" confirmation string per FR-017)
 * 
 * Request body:
 * {
 *   confirmation: "DELETE_ALL"
 * }
 */
router.post('/delete-all', async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const { confirmation } = req.body;
    
    // Require exact confirmation string per FR-017
    if (confirmation !== 'DELETE_ALL') {
      const error = new Error('To delete all reflections, you must send confirmation: "DELETE_ALL"');
      error.statusCode = 400;
      throw error;
    }
    
    const deletedCount = await reflectionService.deleteAllReflections();
    
    res.json({
      message: `All reflections deleted successfully`,
      deletedCount,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections/:id/images
 * Add images to an existing reflection (converts to mixed mode if text exists)
 * Content-Type: multipart/form-data
 * Fields: images (array of files)
 */
router.post('/:id/images', upload.array('images', 10), async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const { id } = req.params;

    if (!req.files || req.files.length === 0) {
      const error = new Error('At least one image file is required');
      error.statusCode = 400;
      throw error;
    }

    // Validate MIME types
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf'];
    for (const file of req.files) {
      if (!allowedTypes.includes(file.mimetype)) {
        const error = new Error(
          `Invalid file type. Allowed types: ${allowedTypes.join(', ')}`
        );
        error.statusCode = 400;
        throw error;
      }
    }

    // Prepare image data
    const imagesData = req.files.map(file => ({
      buffer: file.buffer,
      originalFilename: file.originalname,
      mimeType: file.mimetype,
      sizeBytes: file.size,
    }));

    const updated = await reflectionService.addImagesToReflection(id, imagesData, config.dataDir);

    res.json({
      success: true,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections/:id/external
 * Attach external AI session metadata (persona, summary, chatGPT url) to a reflection
 * Body: { personaId, personaName, sessionSummary, chatGPTUrl, timestamp? }
 */
router.post('/:id/external', async (req, res, next) => {
  try {
    const reflectionService = await getReflectionService();
    const { id } = req.params;
    const { personaId, personaName, sessionSummary, chatGPTUrl, timestamp } = req.body;

    if (!personaId || !personaName || !sessionSummary) {
      const error = new Error('personaId, personaName and sessionSummary are required');
      error.statusCode = 400;
      throw error;
    }

    const sessionData = {
      personaId,
      personaName,
      sessionSummary,
      chatGPTUrl: chatGPTUrl || null,
      timestamp: timestamp || new Date().toISOString(),
    };

    const updated = await reflectionService.updateExternalAISession(id, sessionData);

    if (!updated) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }

    res.json({
      success: true,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
});

export default router;
