/**
 * Reflections routes - HTTP endpoints for reflection management
 * 
 * GET    /api/reflections            - Get all reflections
 * POST   /api/reflections            - Create new reflection
 * GET    /api/reflections/:id        - Get specific reflection
 * DELETE /api/reflections/:id        - Delete specific reflection
 * POST   /api/reflections/delete-all - Delete all reflections (requires confirmation)
 */

import express from 'express';
import multer from 'multer';
import ReflectionService from '../../../domain/services/ReflectionService.js';
import LocalFileRepository from '../../storage/LocalFileRepository.js';
import { validateBody } from '../middleware/validation.js';
import { ReflectionSchema } from '../../../domain/entities/Reflection.js';
import config from '../../../config/index.js';

const router = express.Router();

// Configure multer for memory storage (we'll handle file writing in the service)
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max file size
  },
});

// Initialize service with repository
const repository = new LocalFileRepository();
const reflectionService = new ReflectionService(repository);

/**
 * GET /api/reflections
 * Get all reflections (sorted by timestamp desc)
 */
router.get('/', async (req, res, next) => {
  try {
    const reflections = await reflectionService.getAllReflections();
    res.json({
      reflections,
      count: reflections.length,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/reflections/:id
 * Get specific reflection by ID
 */
router.get('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const reflection = await reflectionService.getReflectionById(id);

    if (!reflection) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }

    res.json(reflection);
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections
 * Create new reflection
 * 
 * For text mode (JSON):
 *   Content-Type: application/json
 *   Body: { mode: 'text', content: '...' }
 * 
 * For visual mode (multipart/form-data):
 *   Content-Type: multipart/form-data
 *   Fields: mode=visual, image=<file>
 * 
 * id, timestamp, aiInteraction are generated by the service
 */
router.post(
  '/',
  upload.single('image'),
  async (req, res, next) => {
    try {
      const { mode } = req.body;

      // Handle visual mode (image upload)
      if (mode === 'visual') {
        if (!req.file) {
          const error = new Error('Image file is required for visual mode');
          error.statusCode = 400;
          throw error;
        }

        // Validate MIME type
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(req.file.mimetype)) {
          const error = new Error(
            `Invalid image type. Allowed types: ${allowedTypes.join(', ')}`
          );
          error.statusCode = 400;
          throw error;
        }

        // Extract dimensions if provided
        const dimensions = req.body.width && req.body.height
          ? { width: parseInt(req.body.width), height: parseInt(req.body.height) }
          : undefined;

        // Create visual reflection using importVisual service method
        const imageData = {
          buffer: req.file.buffer,
          originalFilename: req.file.originalname,
          mimeType: req.file.mimetype,
          sizeBytes: req.file.size,
          dimensions,
        };

        const created = await reflectionService.importVisual(
          imageData,
          config.dataDir
        );

        res.status(201).json(created);
      } 
      // Handle text mode (JSON)
      else {
        const reflectionData = req.body;
        const created = await reflectionService.createReflection(reflectionData);

        res.status(201).json(created);
      }
    } catch (error) {
      next(error);
    }
  }
);

/**
 * DELETE /api/reflections/:id
 * Delete a specific reflection
 */
router.delete('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const deleted = await reflectionService.deleteReflection(id);
    
    if (!deleted) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }
    
    res.json({
      message: 'Reflection deleted successfully',
      id,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections/delete-all
 * Delete all reflections (requires "DELETE_ALL" confirmation string per FR-017)
 * 
 * Request body:
 * {
 *   confirmation: "DELETE_ALL"
 * }
 */
router.post('/delete-all', async (req, res, next) => {
  try {
    const { confirmation } = req.body;
    
    // Require exact confirmation string per FR-017
    if (confirmation !== 'DELETE_ALL') {
      const error = new Error('To delete all reflections, you must send confirmation: "DELETE_ALL"');
      error.statusCode = 400;
      throw error;
    }
    
    const deletedCount = await reflectionService.deleteAllReflections();
    
    res.json({
      message: `All reflections deleted successfully`,
      deletedCount,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/reflections/:id/external
 * Attach external AI session metadata (persona, summary, chatGPT url) to a reflection
 * Body: { personaId, personaName, sessionSummary, chatGPTUrl, timestamp? }
 */
router.post('/:id/external', async (req, res, next) => {
  try {
    const { id } = req.params;
    const { personaId, personaName, sessionSummary, chatGPTUrl, timestamp } = req.body;

    if (!personaId || !personaName || !sessionSummary) {
      const error = new Error('personaId, personaName and sessionSummary are required');
      error.statusCode = 400;
      throw error;
    }

    const sessionData = {
      personaId,
      personaName,
      sessionSummary,
      chatGPTUrl: chatGPTUrl || null,
      timestamp: timestamp || new Date().toISOString(),
    };

    const updated = await reflectionService.updateExternalAISession(id, sessionData);

    if (!updated) {
      const error = new Error('Reflection not found');
      error.statusCode = 404;
      throw error;
    }

    res.json({
      success: true,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
});

export default router;
